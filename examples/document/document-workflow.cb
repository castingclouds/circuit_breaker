use {mock, log, rule} from "tools"

token {
    title: "Circuit Breaker Documentation",
    content: "# Circuit Breaker Pattern

## Summary
This document provides a comprehensive guide to implementing and managing circuit breakers in distributed systems. It covers essential concepts, configuration options, and best practices for effective use of circuit breakers to prevent cascading failures.

## Core Concepts
A detailed explanation of the circuit breaker pattern and its implementation in distributed systems. This document covers the core concepts, configuration options, and best practices for using circuit breakers effectively.

## Implementation Examples
It includes examples of different failure scenarios and how circuit breakers help prevent cascading failures across microservices. The document also discusses important considerations such as timeout settings, failure thresholds, and recovery strategies.

## Best Practices
Additionally, it provides guidance on monitoring and maintaining circuit breakers in production environments.

## Conclusion
By following the guidelines and best practices outlined in this document, teams can effectively implement circuit breakers to improve system resilience and prevent cascading failures.",
    authorId: "author@example.com",
    state: "draft"
}

states = ['draft', 'pending_review', 'reviewed', 'approved', 'rejected']

workflow {
    # The submit transition runs three analysis actions that each return detailed output:
    # analyzeDocument returns:
    # - wordCount: total number of words
    # - analysis: { paragraphs, sentences, averageWordLength }
    # analyzeClarity returns:
    # - score: overall clarity score
    # - clarity: { totalWords, complexWords, readabilityIndex, suggestions }
    # analyzeCompleteness returns:
    # - score: overall completeness score
    # - completeness: { sections, paragraphs, hasSummary, hasConclusion, missingElements }
    transition (submit, draft -> pending_review) {
        actions {
            mock => analyzeDocument
            mock => analyzeClarity
            mock => analyzeCompleteness
        }
        # The policy rules in document-rules.ts use the output from these actions.
        # Required policies (all must pass):
        # - valid_word_count checks wordCount >= 50, sentences >= 3
        # - valid_clarity checks score >= 70, readabilityIndex >= 60
        #
        # Optional policies (at least one must pass):
        # - has_summary checks if document contains a summary section
        # - has_examples checks if document contains code examples
        # - has_conclusion checks if document has a conclusion
        policy {
            all: [valid_word_count, valid_clarity],
            any: [has_summary, has_examples, has_conclusion]
        }
    }

    transition (review, pending_review -> reviewed) {
        actions {
            mock => reviewDocument
        }
        policy {
            all: [valid_review]
        }
    }

    transition (approve, reviewed -> approved) {
        actions {
            mock => finalizeDocument
        }
        policy {
            all: [valid_approval]
        }
    }

    transition (reject, reviewed -> rejected) {
        actions {
            mock => rejectDocument
        }
        policy {
            all: [valid_rejection]
        }
    }
}

# Execute workflow transitions programmatically
test {
    # Initial state logging
    log => "\nExecuting workflow steps...\n"
    log => "Initial state: ${token.state}"
    
    # Try draft -> pending_review transition
    log => "\nTrying draft -> pending_review transition..."
    submit
    log => "Success! New state: ${token.state}"
    
    # Try pending_review -> reviewed transition
    log => "\nTrying pending_review -> reviewed transition..."
    review
    log => "Success! New state: ${token.state}"
    
    # Try reviewed -> approved transition
    log => "\nTrying reviewed -> approved transition..."
    approve
    log => "Success! New state: ${token.state}"
    
    # Print final state
    log => "\nFinal Document State:"
    log => "===================="
    log => "State: ${token.state}\n"
    
    # Print history
    log => "\nDocument History:"
    log => "----------------"
    log => "${token.history}"
}
