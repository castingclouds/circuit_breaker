#!/usr/bin/env ruby

require 'thor'
require_relative '../lib/circuit_breaker'

module CircuitBreaker
  class CLI < Thor
    class_option :debug, type: :boolean, default: false, desc: 'Enable debug output'
    
    desc "workflow FILE", "Execute a workflow from the given file"
    def workflow(file)
      CircuitBreaker::Logger.debug_enabled = options[:debug]
      CircuitBreaker::Logger.debug("Debug mode enabled")

      unless File.exist?(file)
        CircuitBreaker::Logger.error("File '#{file}' not found")
        exit 1
      end

      unless file.end_with?('.cb')
        CircuitBreaker::Logger.error("Unsupported file type: #{file}")
        exit 1
      end

      execute_workflow(file)
    end

    desc "pipeline FILE", "Execute a pipeline from the given file"
    def pipeline(file)
      CircuitBreaker::Logger.debug_enabled = options[:debug]
      CircuitBreaker::Logger.debug("Debug mode enabled")

      unless File.exist?(file)
        CircuitBreaker::Logger.error("File '#{file}' not found")
        exit 1
      end

      unless file.end_with?('.cb')
        CircuitBreaker::Logger.error("Unsupported file type: #{file}")
        exit 1
      end

      execute_pipeline(file)
    end

    private

    def execute_pipeline(file)
      CircuitBreaker::Logger.info("Loading pipeline from #{file}...")
      pipeline = CircuitBreaker.load_pipeline(file)
      
      CircuitBreaker::Logger.info("\nPipeline loaded:")
      CircuitBreaker::Logger.info("Name: #{pipeline.name}")
      CircuitBreaker::Logger.info("Actions:")
      pipeline.actions.each do |tool, action, params|
        CircuitBreaker::Logger.info("  - #{tool} => #{action}")
        CircuitBreaker::Logger.debug("    Parameters: #{params.inspect}")
      end

      CircuitBreaker::Logger.info("\nExecuting pipeline...")
      begin
        result = pipeline.execute
        if result[:success]
          CircuitBreaker::Logger.info("Pipeline executed successfully")
          CircuitBreaker::Logger.debug("Results: #{result[:results].inspect}")
        else
          raise result[:error]
        end
      rescue StandardError => e
        CircuitBreaker::Logger.error("\nError: #{e.message}")
        exit 1
      end
    end

    def execute_workflow(workflow_file)
      CircuitBreaker::Logger.info("Loading workflow from #{workflow_file}...")
      workflow = CircuitBreaker.load_workflow(workflow_file)
      
      CircuitBreaker::Logger.info("\nWorkflow loaded:")
      CircuitBreaker::Logger.info("Token:")
      CircuitBreaker::Logger.info("  Title: #{workflow.token.title}")
      CircuitBreaker::Logger.info("  Content: #{workflow.token.content.lines.first}...")
      CircuitBreaker::Logger.info("  Author: #{workflow.token.author_id}")
      CircuitBreaker::Logger.info("  State: #{workflow.token.state}")
      
      CircuitBreaker::Logger.debug("Full token content:")
      CircuitBreaker::Logger.debug(workflow.token.content)
      
      CircuitBreaker::Logger.info("\nStates:")
      CircuitBreaker::Logger.info("  #{workflow.states.join(' -> ')}")
      
      CircuitBreaker::Logger.info("\nAvailable transitions:")
      workflow.transitions.each do |name, transition|
        CircuitBreaker::Logger.info("  #{name}: #{transition[:from]} -> #{transition[:to]}")
        CircuitBreaker::Logger.debug("  Full transition details:")
        CircuitBreaker::Logger.debug("    Actions: #{transition[:actions].inspect}")
        CircuitBreaker::Logger.debug("    Rules: #{transition[:rules].inspect}")
        if transition[:actions].any?
          CircuitBreaker::Logger.info("    Actions:")
          transition[:actions].each do |tool, action|
            CircuitBreaker::Logger.info("      - #{tool} => #{action}")
          end
        end
        if transition[:rules]
          if transition[:rules][:all]&.any?
            CircuitBreaker::Logger.info("    Required rules:")
            transition[:rules][:all].each do |rule|
              CircuitBreaker::Logger.info("      - #{rule}")
            end
          end
          if transition[:rules][:any]&.any?
            CircuitBreaker::Logger.info("    Optional rules (at least one must pass):")
            transition[:rules][:any].each do |rule|
              CircuitBreaker::Logger.info("      - #{rule}")
            end
          end
        end
      end

      # Execute workflow steps
      CircuitBreaker::Logger.info("\nExecuting workflow steps...\n")
      
      # Try each transition
      begin
        CircuitBreaker::Logger.info("\nTrying draft -> pending_review transition...")
        result = workflow.transition('submit').fire
        if result[:success]
          CircuitBreaker::Logger.info("Success! New state: #{workflow.token.state}")
        else
          raise result[:error]
        end

        CircuitBreaker::Logger.info("\nTrying pending_review -> reviewed transition...")
        result = workflow.transition('review').fire
        if result[:success]
          CircuitBreaker::Logger.info("Success! New state: #{workflow.token.state}")
        else
          raise result[:error]
        end

        CircuitBreaker::Logger.info("\nTrying reviewed -> approved transition...")
        result = workflow.transition('approve').fire
        if result[:success]
          CircuitBreaker::Logger.info("Success! New state: #{workflow.token.state}")
        else
          raise result[:error]
        end

        # Print final state
        CircuitBreaker::Logger.info("\nFinal Document State:")
        CircuitBreaker::Logger.info("====================")
        CircuitBreaker::Logger.info("State: #{workflow.token.state}\n")
        CircuitBreaker::Logger.info(workflow.token.to_json(true))

        # Print history
        CircuitBreaker::Logger.info("\nDocument History:")
        CircuitBreaker::Logger.info("----------------")
        workflow.token.history.each do |event|
          CircuitBreaker::Logger.info("#{event[:timestamp]}: #{event[:transition]} from #{event[:from]} to #{event[:to]}")
        end
      rescue StandardError => e
        CircuitBreaker::Logger.error("\nError: #{e.message}")
        exit 1
      end
    end

    desc "version", "Show version information"
    def version
      puts "Circuit Breaker v0.1.0"
    end

    def self.exit_on_failure?
      true
    end
  end
end

CircuitBreaker::CLI.start(ARGV)
